#pragma config(Sensor, S1,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          driveMotLeft,  tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorB,          driveMotRight, tmotorEV3_Large, openLoop, driveRight)
#pragma config(Motor,  motorC,          handlebarMotor, tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "kalmangyr.h"

// Function prototypes
float updatePIDSteer(float setpoint, float measurement, float dt);
void calibrateGyro();

// Defines
#define DEG2RAD (PI/180.0)
#define RAD2DEG (180.0/PI)

#define SAMPLE_TIME (float) 0.005
#define CALIB_ITER (int) 10

// Steer controller parameters
#define KP_STEER (float) 13.0
#define KI_STEER (float) 0.00
#define KD_STEER (float) 0.10
#define TF_STEER (float) 0.05

#define LIM_MAX_STEER (float) 60.0
#define LIM_MIN_STEER (float) -60.0
#define LIM_I_MAX_STEER (float) 30.0
#define LIM_I_MIN_STEER (float) -30.0

// Motor PID
#define KP_MOTOR (float) 4.0

// Gyro low-pass filter coefficient
#define LPF_ALPHA (float) 0.5

// Kalman filter
struct KalmanFilter kf;

// Global variables
float leanAngle;
float leanRate;

float gyroBias;

float time;


task main() {

	writeDebugStreamLine("Started.");
	datalogClear();

	displayCenteredTextLine(0, "Initialising...");
	resetMotorEncoder(handlebarMotor);
	sleep(1000);

	// Get initial gyro bias
	calibrateGyro();
	leanAngle = 0.0;
	leanRate = 0.0;

	KalmanInit(&kf, gyroBias, 0.1, 0.1, 0.1);

	// Set motor speed
	setMotorSpeed(driveMotLeft, 100.0);
	setMotorSpeed(driveMotRight, 100.0);

	// Main loop
	time = 0.0;
	clearTimer(T1);

	displayCenteredBigTextLine(0, "RUNNING...");

	while (true) {

		/*
		* Calculate sample time
		*/
		float dt = time1[T1] / 1000.0;

		if (dt >= SAMPLE_TIME) {

			clearTimer(T1);

			/*
			*	Acquire and filter sensor data
			*/
			leanRate = LPF_ALPHA * leanRate + (1 - LPF_ALPHA) * (-getGyroRate(gyroSensor) - kf.x[1]);
			leanAngle = leanAngle + dt * leanRate;

			KalmanUpdate(&kf, leanAngle, leanRate, dt);

			/*
			* Get controller output
			*/
			float steerAngleSetpoint = updatePIDSteer(0.0, kf.x[0], dt);

			/*
			*
			*/
			int steerAngleCorrection = (int) round(KP_MOTOR * (steerAngleSetpoint - (float) getMotorEncoder(handlebarMotor)));

			setMotorSpeed(handlebarMotor, steerAngleCorrection);


			time += SAMPLE_TIME;

			// Save to datalog
			int scale = 100;
			datalogDataGroupStart();
			datalogAddValue(0, getMotorRPM(driveMotLeft)); // Drive motor rpm
			datalogAddValue(1, getMotorEncoder(handlebarMotor)); // Steer angle
			datalogAddValue(2, (int) round(leanAngle)); // Lean angle
			datalogAddValue(3, (int) round(steerAngleSetpoint)); // Controller output
			datalogDataGroupEnd();

		}

	}

	datalogClose();

}


// Calculate average gyro bias
void calibrateGyro() {

	resetGyro(gyroSensor);
	sleep(3000);

	gyroBias = 0.0;

	for (int i = 0; i < CALIB_ITER; i++) {
		gyroBias += -getGyroRate(gyroSensor);
		delay(100);
	}

	gyroBias = gyroBias /(float) CALIB_ITER;

}

float updatePIDSteer(float setpoint, float measurement, float dt) {
	static float integral = 0.0;
	static float derivative = 0.0;
	static float prevError = 0.0;
	static float prevMeasurement = 0.0;

  float error = setpoint - measurement;

  /* Proportional */
  float proportional = KP_STEER * error;

  /* Integral */
  integral = integral + 0.5 * KI_STEER * dt * (error + prevError);

  /* Clamp integral */
  if (integral > LIM_I_MAX_STEER)
    integral = LIM_I_MAX_STEER;
  else if (integral < LIM_I_MIN_STEER)
    integral = LIM_I_MIN_STEER;

  /* Derivative (on measurement) */
  derivative = (2 * KD_STEER * (prevMeasurement - measurement) - derivative * (dt - 2 * TF_STEER)) / (2 * TF_STEER + dt);

  /* Calculate controller output */
  float controllerOutput = proportional + integral + derivative;

  /* Clamp output */
  if (controllerOutput > LIM_MAX_STEER)
    controllerOutput = LIM_MAX_STEER;
  else if (controllerOutput < LIM_MIN_STEER)
    controllerOutput = LIM_MIN_STEER;

  prevError = error;
  prevMeasurement = measurement;

  return controllerOutput;
}
