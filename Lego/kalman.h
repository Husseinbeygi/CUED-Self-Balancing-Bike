#ifndef KALMAN_H
#define KALMAN_H

struct KalmanFilter {

	float x[4];

	float A[4][4]; float At[4][4];
	float B[4];

	float P[4][4];

	float Q[4][4];
	float R[4][4];

	float K[4][4];

};

int KalmanUpdate(struct KalmanFilter *kal, float *measurement, float u, float v, float dt) {

	int i, j, k;
	dt = 1;

	// Update state transition matrix
	kal->A[0][0] = 0; 	 kal->A[0][1] = 0; 						kal->A[0][2] = 1; 		 kal->A[0][3] = 0;
	kal->A[1][0] = 0; 	 kal->A[1][1] = 0; 						kal->A[1][2] = 0; 		 kal->A[1][3] = 1;
	kal->A[2][0] = 194;  kal->A[2][1] = -1.47-80*v*v; kal->A[2][2] = -v; 		 kal->A[2][3] = -11.9*v;
	kal->A[3][0] = 15.1; kal->A[3][1] = 229-20*v*v; 	kal->A[3][2] = 20.9*v; kal->A[3][3] = -8.24*v;

	// Calculate transpose
  for (i = 0; i < 4; i++)
  	for(j = 0; j < 4; j++)
    	kal->At[j][i] = kal->A[i][j];

	// 1) x+ = x- + T*(A*x- + B*u)
	float xhatplus[4];
	for (i = 0; i < 4; i++) {

		xhatplus[i] = kal->x[i] + dt * kal->B[i] * u;

		for (j = 0; j < 4; j++)
			xhatplus[i] += dt * kal->A[i][j] * kal->x[j];

	}

	// 2) P+ = T*(A*P-*At + Q)
	float PminAtran[4][4];
	float m[4][4];

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {
			PminAtran[i][j] = 0;
			for (k = 0; k < 4; k++) {
				PminAtran[i][j] += kal->P[i][k] * kal->At[k][j];
			}
		}
	}

	for (i = 0; i < 4; i++) {
		for (j = 0; j < 4; j++) {

			kal->P[i][j] = kal->Q[i][j];

			for (k = 0; k < 4; k++) {
				kal->P[i][j] += kal->A[i][k] * PminAtran[k][j];
			}

			kal->P[i][j] = dt * kal->P[i][j];
			m[i][j] = kal->P[i][j] + kal->R[i][j];

		}
	}

	// 3) K = P+ * (P+ + R)^-1
  float inv[4][4];
  float det;

  inv[0][0] = m[1][1]  * m[2][2] * m[3][3] -
           m[1][1]  * m[2][3] * m[3][2] -
           m[2][1]  * m[1][2] * m[3][3] +
           m[2][1]  * m[1][3] * m[3][2] +
           m[3][1]  * m[1][2] * m[2][3] -
           m[3][1]  * m[1][3] * m[2][2];

  inv[1][0] = -m[1][0]  * m[2][2] * m[3][3] +
            m[1][0]  * m[2][3] * m[3][2] +
            m[2][0]  * m[1][2]  * m[3][3] -
            m[2][0]  * m[1][3]  * m[3][2] -
            m[3][0]  * m[1][2]  * m[2][3] +
            m[3][0]  * m[1][3]  * m[2][2];

  inv[2][0] = m[1][0]  * m[2][1] * m[3][3] -
           m[1][0]  * m[2][3] * m[3][1] -
           m[2][0]  * m[1][1] * m[3][3] +
           m[2][0]  * m[1][3] * m[3][1] +
           m[3][0]  * m[1][1] * m[2][3] -
           m[3][0]  * m[1][3] * m[2][1];

  inv[3][0] = -m[1][0]  * m[2][1] * m[3][2] +
             m[1][0]  * m[2][2] * m[3][1] +
             m[2][0]  * m[1][1] * m[3][2] -
             m[2][0]  * m[1][2] * m[3][1] -
             m[3][0]  * m[1][1] * m[2][2] +
             m[3][0]  * m[1][2] * m[2][1];

  inv[0][1] = -m[0][1]  * m[2][2] * m[3][3] +
            m[0][1]  * m[2][3] * m[3][2] +
            m[2][1]  * m[0][2] * m[3][3] -
            m[2][1]  * m[0][3] * m[3][2] -
            m[3][1]  * m[0][2] * m[2][3] +
            m[3][1]  * m[0][3] * m[2][2];

  inv[1][1] = m[0][0]  * m[2][2] * m[3][3] -
           m[0][0]  * m[2][3] * m[3][2] -
           m[2][0]  * m[0][2] * m[3][3] +
           m[2][0]  * m[0][3] * m[3][2] +
           m[3][0]  * m[0][2] * m[2][3] -
           m[3][0]  * m[0][3] * m[2][2];

  inv[2][1] = -m[0][0]  * m[2][1] * m[3][3] +
            m[0][0]  * m[2][3] * m[3][1] +
            m[2][0]  * m[0][1] * m[3][3] -
            m[2][0]  * m[0][3] * m[3][1] -
            m[3][0]  * m[0][1] * m[2][3] +
            m[3][0]  * m[0][3] * m[2][1];

  inv[3][1] = m[0][0]  * m[2][1] * m[3][2] -
            m[0][0]  * m[2][2] * m[3][1] -
            m[2][0]  * m[0][1] * m[3][2] +
            m[2][0]  * m[0][2] * m[3][1] +
            m[3][0]  * m[0][1] * m[2][2] -
            m[3][0]  * m[0][2] * m[2][1];

  inv[0][2] = m[0][1]  * m[1][2] * m[3][3] -
           m[0][1]  * m[1][3] * m[3][2] -
           m[1][1]  * m[0][2] * m[3][3] +
           m[1][1]  * m[0][3] * m[3][2] +
           m[3][1]  * m[0][2] * m[1][3] -
           m[3][1]  * m[0][3] * m[1][2];

  inv[1][2] = -m[0][0]  * m[1][2] * m[3][3] +
            m[0][0]  * m[1][3] * m[3][2] +
            m[1][0]  * m[0][2] * m[3][3] -
            m[1][0]  * m[0][3] * m[3][2] -
            m[3][0]  * m[0][2] * m[1][3] +
            m[3][0]  * m[0][3] * m[1][2];

  inv[2][2] = m[0][0]  * m[1][1] * m[3][3] -
            m[0][0]  * m[1][3] * m[3][1] -
            m[1][0]  * m[0][1] * m[3][3] +
            m[1][0]  * m[0][3] * m[3][1] +
            m[3][0]  * m[0][1] * m[1][3] -
            m[3][0]  * m[0][3] * m[1][1];

  inv[3][2] = -m[0][0]  * m[1][1] * m[3][2] +
             m[0][0]  * m[1][2] * m[3][1] +
             m[1][0]  * m[0][1] * m[3][2] -
             m[1][0]  * m[0][2] * m[3][1] -
             m[3][0]  * m[0][1] * m[1][2] +
             m[3][0]  * m[0][2] * m[1][1];

  inv[0][3] = -m[0][1] * m[1][2] * m[2][3] +
            m[0][1] * m[1][3] * m[2][2] +
            m[1][1] * m[0][2] * m[2][3] -
            m[1][1] * m[0][3] * m[2][2] -
            m[2][1] * m[0][2] * m[1][3] +
            m[2][1] * m[0][3] * m[1][2];

  inv[1][3] = m[0][0] * m[1][2] * m[2][3] -
           m[0][0] * m[1][3] * m[2][2] -
           m[1][0] * m[0][2] * m[2][3] +
           m[1][0] * m[0][3] * m[2][2] +
           m[2][0] * m[0][2] * m[1][3] -
           m[2][0] * m[0][3] * m[1][2];

  inv[2][3] = -m[0][0] * m[1][1] * m[2][3] +
             m[0][0] * m[1][3] * m[2][1] +
             m[1][0] * m[0][1] * m[2][3] -
             m[1][0] * m[0][3] * m[2][1] -
             m[2][0] * m[0][1] * m[1][3] +
             m[2][0] * m[0][3] * m[1][1];

  inv[3][3] = m[0][0] * m[1][1] * m[2][2] -
            m[0][0] * m[1][2] * m[2][1] -
            m[1][0] * m[0][1] * m[2][2] +
            m[1][0] * m[0][2] * m[2][1] +
            m[2][0] * m[0][1] * m[1][2] -
            m[2][0] * m[0][2] * m[1][1];

  det = m[0][0] * inv[0][0] + m[0][1] * inv[1][0] + m[0][2] * inv[2][0] + m[0][3] * inv[3][0];

  if (det == 0)
      return 0;

  det = 1.0 / det;

  for (i = 0; i < 4; i++)
  	for (j = 0; j < 4; j++)
      inv[i][j] = inv[i][j] * det;

  // K = P+ * inverse
  float Pplus[4][4];

  for (i = 0; i < 4; i++)
  	for (j = 0; j < 4; j++) {

  		kal->K[i][j] = 0.0;

  		for (k = 0; k < 4; k++)
  			kal->K[i][j] += kal->P[i][k] * inv[k][j];

  		Pplus[i][j] = kal->P[i][j];

  }

  // 4) P++ = (I - K) * P+
  for (i = 0; i < 4; i++)
  	for (j = 0; j < 4; j++) {

  		kal->P[i][j] = 0.0;

  		for (k = 0; k < 4; k++)
  		    if (i == k) {
  			    kal->P[i][j] += (1.0 - kal->K[i][k]) * Pplus[k][j];
  		    } else {
  		        kal->P[i][j] += (0.0 - kal->K[i][k]) * Pplus[k][j];
  		    }

  }

  // 5) x++ = x+ + K * (y - x+)
  for (i = 0; i < 4; i++) {

  	kal->x[i] = xhatplus[i];

  	for (j = 0; j < 4; j++)
  		kal->x[i] += kal->K[i][j] * (measurement[j] - xhatplus[j]);

	}

  return 1;

}

void KalmanInit(struct KalmanFilter *kal, float valQ, float valR) {

	int i, j;

	for (i = 0; i < 4; i++) {

		kal->x[i] = 0.0;

		for (j = 0; j < 4; j++) {

			kal->P[i][j] = 0.0;

			if (i == j) {
				kal->Q[i][j] = valQ;
				kal->R[i][j] = valR;
			} else {
			    kal->Q[i][j] = 0;
			    kal->R[i][j] = 0;
			}

		}

	}



	kal->B[0] = 0.0; kal->B[1] = 0.0; kal->B[2] = -4674; kal->B[3] = 97659;

}

#endif
