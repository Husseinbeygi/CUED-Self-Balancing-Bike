#pragma config(Sensor, S1,     gyroSensor,     sensorEV3_Gyro, modeEV3Gyro_Rate)
#pragma config(Motor,  motorA,          driveMotLeft,  tmotorEV3_Large, openLoop, driveLeft, encoder)
#pragma config(Motor,  motorB,          driveMotRight, tmotorEV3_Large, openLoop, driveRight)
#pragma config(Motor,  motorC,          handlebarMotor, tmotorEV3_Large, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "kalmangyr.h"

#define DEG2RAD (PI/180.0)
#define RAD2DEG (180.0/PI)

// General settings
const float wheelRadius = 0.04;
const float T = 0.01;

// Controller
const float Kph = 14.0; // 8
const float Kih = 30.00;
const float Kdh = 0.3;  // 3
const float tau = 0.003; //0.00062;

float hderiv = 0.0;
float hderivprev = 0.0;

float prevMeas = 0.0;
float dprev = 0.0;

float integrator = 0.0;

// Kalman filter
struct KalmanFilter kal;
float kalPinit = 0.1;
float kalQ = 0.1;
float kalR = 0.1;

// Variables
float measurements[4];
float u;
float vel;
float gyro_rate_bias;
float time;

float ref = 0.0;
float prevRef = 0.0;

// Function prototypes
void calibrateGyro(int iterations);
float Compensator(float error, float dt);
float HInf(float error);
float lqr(float measurement, float input, float dt);

task main() {

	writeDebugStreamLine("Started.");
	datalogClear();

	displayCenteredTextLine(0, "Initialising...");
	resetMotorEncoder(handlebarMotor);
	sleep(1000);

	// Get initial gyro bias
	calibrateGyro(10);
	measurements[2] = 0.0;

	// Initialise Kalman filter
	KalmanInit(&kal, gyro_rate_bias * DEG2RAD, kalPinit, kalQ, kalR);

	// Set motor speed
	setMotorSpeed(driveMotLeft, 100.0);
	setMotorSpeed(driveMotRight, 100.0);

	// Main loop
	time = 0.0;
	clearTimer(T1);

	float gyrlpf = 0.0;
	int speedctrl;
	float speedctrlint = 0.0;

	while (true) {

		float dt = time1[T1] / 1000.0;
		if (dt >= T) {

			clearTimer(T1);

			float v = getMotorRPM(driveMotLeft) * 2 * PI * 0.043 / 60.0;

			// Get readings from sensors
			gyrlpf = 0.5 * gyrlpf + 0.5 * (-getGyroRate(gyroSensor) - gyro_rate_bias);
			measurements[2] = (gyrlpf * DEG2RAD); // PHIDOT
			measurements[0] = kal.x[0] + dt * measurements[2]; // PHI
			measurements[1] = getMotorEncoder(handlebarMotor); // DELTA
			measurements[3] = 0.0; // DELTADOT

			// Get lean angle estimate
			KalmanUpdate(&kal, measurements[0], measurements[2], dt);

			// Get control output
			integrator = integrator + Kih * (dt / 2.0) * ((ref - measurements[0] * RAD2DEG) - (prevRef - prevMeas));
			if (integrator > 45)
				integrator = 45;
			else if (integrator < -45)
				integrator = -45;

			hderiv = (2 * Kdh * (prevMeas - measurements[0] * RAD2DEG)+ (2 * tau - dt) * hderiv) / (2 * tau + dt);
			prevMeas = measurements[0] * RAD2DEG;

		//	u = Kph * (ref - measurements[0] * RAD2DEG) + hderiv + integrator;
		//	prevRef = ref;

	//		u = HInf(0.0 - measurements[0] * RAD2DEG);


			u = Compensator(0.0 - measurements[0] * RAD2DEG, dt);

			float error = u - getMotorEncoder(handlebarMotor);

			//int motctrl = motPIDupdate(error, dt);
			//setMotorSpeed(handlebarMotor, motctrl);

			setMotorSpeed(handlebarMotor, 2 * error);
			//setMotorSpeed(handlebarMotor, 5 * error - 0.1 * (getMotorRPM(handlebarMotor) + dprev) / 2.0);
			//dprev = getMotorRPM(handlebarMotor);

		//	setMotorTarget(handlebarMotor, u - getMotorEncoder(handlebarMotor), 100);

			// Display information on screen
			displayCenteredTextLine(0, "Phi: %f", kal.x[0] * RAD2DEG);
			displayCenteredTextLine(1, "PhiDot: %f", measurements[2] * RAD2DEG);
			displayCenteredTextLine(2, "Delta: %f", measurements[1]);
			displayCenteredTextLine(3, "DeltaDot: %f", measurements[3]);
			displayCenteredTextLine(5, "Bias: %f", kal.x[1] * RAD2DEG);

			displayCenteredTextLine(7, "u: %f", u);
			displayCenteredTextLine(8, "motu: %d", getMotorEncoder(handlebarMotor));

			time += dt;

			// Save to datalog
			int scale = 100;
			datalogDataGroupStart();
			datalogAddValue(0, (int) round(100 * v)); // Forward speed (cm/s)                                                                                                                                                                                                                                                                                                                                                                                    mer
			datalogAddValue(1, -getMotorEncoder(handlebarMotor)); // Steer angle
			datalogAddValue(2, (int) round(measurements[0] * RAD2DEG)); // Lean angle
			datalogAddValue(3, (int) round(-u)); // Controller output
			datalogDataGroupEnd();

		}

	}

	datalogClose();

}

// Calculate average gyro bias
void calibrateGyro(int iterations) {

	writeDebugStreamLine("Calibrating Gyro.");

	resetGyro(gyroSensor);
	sleep(3000);

	writeDebugStreamLine("Taking measurements...");

	measurements[0] = 0.0;
	gyro_rate_bias = 0.0;

	for (int i = 0; i < iterations; i++) {
		gyro_rate_bias += -getGyroRate(gyroSensor);
		delay(100);
	}

	writeDebugStreamLine("Iterations: %d | Bias sum: %f", iterations, gyro_rate_bias);
	gyro_rate_bias = gyro_rate_bias /(float) iterations;

}

float Compensator(float error, float dt) {

	static float u[2] = {0.0, 0.0};
	static float y[2] = {0.0, 0.0};

	static float k = 15.5;
	static float a =  5.0;
	static float b = -2.0;

	u[1] = u[0]; u[0] = error;
	y[1] = y[0];

	y[0] = (u[0] * k * (a * dt + 2.0) + u[1] * k * (a * dt - 2.0) - y[1] * (b * dt - 2.0)) / (b * dt + 2.0);

	return y[0];

}

float HInf(float error) {

	static float u[10] = {0,0,0,0,0,0,0,0,0,0};
	static float y[10] = {0,0,0,0,0,0,0,0,0,0};

	const int N = 9;
	static float num[N] = {14.7411557774660,-65.4830401787797,106.041602215354,-52.3627605396015,-57.0556402628636,99.9123438245945,-61.7070340487058,17.9336468685246,-2.01989370651304};
	static float den[N] = {1,-5.59106738200150,13.6110414303059,-18.7871301914909,16.0156806250330,-8.59198699890150,2.81720561210018,-0.513370770965323,0.0396445723866825};

	u[9] = u[8]; u[8] = u[7]; u[7] = u[6]; u[6] = u[5]; u[5] = u[4]; u[4] = u[3]; u[3] = u[2]; u[2] = u[1]; u[1] = u[0]; u[0] = error;
	y[9] = y[8]; y[8] = y[7]; y[7] = y[6]; y[6] = y[5]; y[5] = y[4]; y[4] = y[3]; y[3] = y[2]; y[2] = y[1]; y[1] = y[0];

	y[0] = num[0] * u[0] + num[1] * u[1] + num[2] * u[2] + num[3] * u[3] + num[4] * u[4] + num[5] * u[5] + num[6] * u[6]
											+ num[7] * u[7] + num[8] * u[8];
	y[0] = y[0] - (den[1] * y[1] + den[2] * y[2] + den[3] * y[3] + den[4] * y[4] + den[5] * y[5] + den[6] * y[6]
									+ den[7] * u[7] + den[8] * y[8]);

	return y[0];

}

float lqr(float measurement, float input, float dt) {

	static float x1 = 0.0;
	static float x2 = 0.0;

	const static float L[2] = {0.6282, -1.0768};
	const static float K[2] = {170.32, 18.0584};

	x1 = x1 + T * ((0.0 - L[0] * 7.8222) * x1 + (1.0 - L[0] * 1.7778) * x2 + L[0] * measurement);
	x2 = x2 + T * ((89.1818 - L[1] * 7.8222) * x1 + (0.0 - L[1] * 1.7778) * x2 + L[1] * measurement + input);

	float output = -(K[0] * x1 + K[1] * x2);

	return output;

}
